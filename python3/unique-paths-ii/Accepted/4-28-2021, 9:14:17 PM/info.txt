{"id":486313005,"lang":"cpp","time":"1 year, 1 month","timestamp":1619624657,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/486313005/","is_pending":"Not Pending","title":"Unique Paths II","memory":"7.6 MB","code":"class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\n        int m = size(grid), n = size(grid[0]);\n        grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\n        /* For each cell of first row and column, we can either reach that cell in 1 way\n         * if previous column/row cell are not obstacle respectively, or not reach it at all.\n         * That's what we are doing below */\n        for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \n        for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\n        // same process as in above solutions -\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)            \n                grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \n        return grid[m - 1][n - 1];\n    }\n};","compare_result":"11111111111111111111111111111111111111111","title_slug":"unique-paths-ii"}