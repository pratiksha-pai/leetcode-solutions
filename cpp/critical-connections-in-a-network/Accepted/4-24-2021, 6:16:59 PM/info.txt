{"id":484574285,"lang":"cpp","time":"1 year, 1 month","timestamp":1619268419,"status_display":"Accepted","runtime":"528 ms","url":"/submissions/detail/484574285/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"180.2 MB","code":"class Solution {\npublic:\n    \n    vector<vector<int>> ans; // required answer\n    vector<vector<int>> adj; // undirected graph\n    vector<int> id; // id number\n    vector<int> low; // lowlink value\n    vector<int> par; // parent\n    int time=0; // time\n    \n    void dfs(int node){\n        id[node]=low[node]=time++; // incrementing time after each node gets visited\n        for(int &u:adj[node]) //exploring all the adjacent nodes of node\n        {\n            if(id[u]==-1) // checking if adjacent node is unvisited\n            {\n                par[u]=node; // assigning node as parent of adjacent node\n                dfs(u); // performing dfs for adjacent node\n                low[node]=min(low[node],low[u]); // minimising lowlink value of node\n                if(id[node]<low[u]) // checking if we have a bridge yet\n                    ans.push_back({node,u});\n            }\n            else if(u!=par[node]) // checking if adjacent is not parent of node\n                low[node]=min(low[node],id[u]); // minimising lowlink value of node\n        }\n    }\n    \n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        adj.resize(n);\n        par.resize(n,-1);\n        low.resize(n,-1);\n        id.resize(n,-1);\n        for(int i=0;i<connections.size();i++){ // building our graph\n            adj[connections[i][0]].push_back(connections[i][1]); \n            adj[connections[i][1]].push_back(connections[i][0]);\n        }\n        for(int i=0;i<n;i++) // performing dfs on unvisited nodes\n        {\n            if(id[i]==-1)\n                dfs(i);\n        }\n        return ans;\n    }\n};","compare_result":"111111111111","title_slug":"critical-connections-in-a-network"}