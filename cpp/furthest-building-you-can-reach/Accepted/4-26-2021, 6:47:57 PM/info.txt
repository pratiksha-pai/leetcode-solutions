{"id":485427793,"lang":"cpp","time":"1 year, 1 month","timestamp":1619443077,"status_display":"Accepted","runtime":"92 ms","url":"/submissions/detail/485427793/","is_pending":"Not Pending","title":"Furthest Building You Can Reach","memory":"53.7 MB","code":"class Solution {\npublic:\n    int furthestBuilding(vector<int>& H, int bricks, int ladders) {\n\tint i = 0, n = size(H), jumpHeight;\n\t// pq will store the first ladder numbr of largest jumps\n\tpriority_queue<int, vector<int> ,greater<int> > pq;\n\t// first ladder number of jumps would be assumed to be the largest\n\t// hence, push all these jumps into the queue\n\twhile (i < n - 1 && size(pq) < ladders) {\n\t\tjumpHeight = H[i + 1] - H[i];\n\t\tif(jumpHeight > 0) \n\t\t\tpq.push(jumpHeight);\n\t\ti++;            \n\t}\n\t// From here, we can't just use ladder and need to spend bricks from now on...\n\twhile (i < n - 1) {\n\t\tjumpHeight = H[i + 1] - H[i];\n\t\t// if next building is bigger than current, bricks need to be used\n\t\tif(jumpHeight > 0) {\n\t\t\t// First check if we have a previous jump requiring less number of bricks than currentDiff\n\t\t\tif(!pq.empty() && pq.top() < jumpHeight) {                    \n\t\t\t\t// if there is, just use bricks for that jump and assign ladder for current one\n\t\t\t\tbricks -= pq.top(); pq.pop(); \n\t\t\t\tpq.push(jumpHeight);                    \n\t\t\t}\n\t\t\t// jumpHeight is already minimum jump size. So, no choice than spending that many bricks\n\t\t\telse bricks -= jumpHeight;    \n\t\t}\n\t\t// if bricks become negative, we can't travel any further as all bricks and ladders are used up\n\t\tif(bricks < 0) return i;\n\t\ti++;\n\t}\n\treturn i;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"furthest-building-you-can-reach"}