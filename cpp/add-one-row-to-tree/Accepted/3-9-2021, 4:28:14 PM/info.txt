{"id":465546194,"lang":"cpp","time":"1 year, 3 months","timestamp":1615287494,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/465546194/","is_pending":"Not Pending","title":"Add One Row to Tree","memory":"25.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* addOneRow(TreeNode* root, int v, int d) {\n        if(root == NULL) return NULL;\n        if(d == 1){\n            TreeNode* temp = new TreeNode(v);\n            temp->left = root;\n            root = temp;\n        }\n        int curr_depth = 1;\n        queue<TreeNode*> q1;\n        queue<TreeNode*> q2;\n        int flag = 0;\n        q1.push(root);\n        while(!q1.empty() || !q2.empty()){\n            if(curr_depth + 1 == d) {\n                flag = 0;\n                break;\n            }\n            while(!q1.empty()){\n                TreeNode* temp = q1.front();\n                q1.pop();\n                if(temp->left) q2.push(temp->left);\n                if(temp->right) q2.push(temp->right);\n            }\n            curr_depth++;\n            if(curr_depth + 1 == d) {\n                flag = 1;\n                break;\n            }\n            while(!q2.empty()){\n                TreeNode* temp = q2.front();\n                q2.pop();\n                if(temp->left) q1.push(temp->left);\n                if(temp->right) q1.push(temp->right);\n            }\n            curr_depth++; \n        }\n        if(flag == 0){\n//             operations on q1 -> q1 not empty \n            while(!q1.empty()){\n                TreeNode* temp = q1.front();\n                q1.pop();\n                \n                TreeNode* left_new_node = new TreeNode(v); \n                left_new_node->left = temp->left;\n                temp->left = left_new_node;\n                \n                TreeNode* right_new_node = new TreeNode(v); \n                right_new_node->right = temp->right;\n                temp->right = right_new_node;\n                \n            }\n        }else{\n//             operations on q2 -> q2 not empty\n            while(!q2.empty()){\n                TreeNode* temp = q2.front();\n                q2.pop();\n                \n                TreeNode* left_new_node = new TreeNode(v); \n                left_new_node->left = temp->left;\n                temp->left = left_new_node;\n                \n                TreeNode* right_new_node = new TreeNode(v); \n                right_new_node->right = temp->right;\n                temp->right = right_new_node;\n                \n            }\n            \n        }\n        \n        \n        \n        return root;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"add-one-row-to-tree"}